<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lightweight Interactive Kana Chart</title>
    <style>
        /* Core Styles for a Light & Fast Experience */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background-color: #f0f2f5; color: #333; }
        .container { max-width: 1200px; margin: 0 auto; padding: 15px; }
        .header { text-align: center; margin-bottom: 20px; }
        .header h1 { font-size: 2rem; margin-bottom: 5px; color: #1d2129; }
        .controls { display: flex; justify-content: center; gap: 15px; margin-bottom: 10px; /* Reduced margin */ flex-wrap: wrap; }
        .btn { padding: 10px 20px; border: 1px solid transparent; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; background-color: #e4e6eb; color: #050505; transition: background-color 0.2s ease, border-color 0.2s ease; }
        .btn:hover { background-color: #d8dadf; }
        .btn.active { color: #fff; background-color: #1877f2; border-color: #1877f2; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .chart-container { display: grid; grid-template-columns: 1fr; gap: 20px; margin-bottom: 20px; }
        .chart { background: #fff; border-radius: 8px; padding: 15px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .chart h2 { text-align: center; margin-bottom: 15px; font-size: 1.5rem; }
        .hiragana h2 { color: #e44d26; }
        .katakana h2 { color: #2965f1; }
        .kana-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; max-width: 500px; margin: 0 auto; }
        .kana-cell { aspect-ratio: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; background: #fff; transition: background-color 0.2s ease, transform 0.2s ease; }
        .kana-cell:hover { background-color: #f0f2f5; transform: scale(1.05); }
        .kana-cell.selected { background-color: #1877f2; color: white; border-color: #1877f2; }
        .kana-char { font-size: 1.6rem; font-weight: bold; }
        .kana-romaji { font-size: 0.7rem; color: #606770; text-transform: uppercase; }
        .kana-cell.selected .kana-romaji { color: #fff; }
        .header-cell { background: #f0f2f5; color: #606770; font-weight: bold; cursor: default; }
        .header-cell:hover { transform: none; background-color: #f0f2f5; }
        .practice-area { background: #fff; border-radius: 8px; padding: 20px; text-align: center; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .practice-char { font-size: 6rem; font-weight: bold; margin: 10px 0; color: #1d2129; min-height: 100px; }
        .practice-info { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin: 15px 0; }
        .info-card { background: #f0f2f5; padding: 15px; border-radius: 8px; }
        .info-card h3 { font-size: 1rem; color: #606770; margin-bottom: 5px; }
        .info-card p { font-size: 1.2rem; font-weight: bold; }
        .pronunciation-tips { background-color: #fff; padding: 20px; border-radius: 8px; margin-top: 20px; }
        .tips-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px; margin-top: 15px; }
        .tip-item { background: #f0f2f5; padding: 10px; border-radius: 6px; border-left: 3px solid #1877f2; }
        .voice-status { padding: 10px; border-radius: 6px; margin: 15px 0; font-weight: bold; text-align: center; }
        .voice-status.error { background: #fbe3e4; color: #d12f2f; }
        .voice-status.success { background: #e8f5e9; color: #2e7d32; }
        .hidden { display: none !important; }
        /* New styles for LLM features */
        .llm-features {
            background: #fff;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            margin-top: 10px; /* Reduced margin */
            margin-bottom: 20px; /* Ensure space below */
        }
        .llm-features .info-card {
            margin-top: 15px;
        }
        #loadingIndicator {
            padding: 10px;
            font-weight: bold;
            color: #1877f2;
        }
        .practice-char.small {
            font-size: 4rem; /* Smaller size for example words */
        }
        .text-left {
            text-align: left;
            padding: 10px;
            line-height: 1.5;
        }
        /* Handwriting canvas styles */
        .canvas-container {
            display: flex;
            justify-content: center;
            gap: 10px; /* Space between the two canvases */
            margin: 10px auto;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        #handwritingCanvas, #referenceCanvas {
            border: 1px solid #ccc;
            background-color: #f9f9f9; /* Canvas background color */
            cursor: crosshair;
            touch-action: none; /* Prevent scrolling on touch devices while drawing */
        }
        #handwritingFeedback {
            margin-top: 10px;
            font-weight: bold;
        }

        /* Responsive Design */
        @media (min-width: 768px) {
            .chart-container { grid-template-columns: 1fr 1fr; }
        }
        @media (max-width: 600px) {
            .kana-grid { grid-template-columns: repeat(auto-fit, minmax(45px, 1fr)); }
            .practice-char { font-size: 5rem; }
            .practice-char.small { font-size: 3rem; }
            #handwritingCanvas, #referenceCanvas {
                width: 120px;
                height: 120px;
            }
            .canvas-container {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéå Interactive Japanese Kana Learning Chart</h1>
            <p>Click on any character to learn its pronunciation and romaji.</p>
        </div>

        <div class="controls">
            <button class="btn active" id="btnBasic">Basic Characters</button>
            <button class="btn" id="btnDakuten">Dakuten & Handakuten</button>
            <button class="btn" id="audioBtn" disabled>üîä Play Sound</button>
            <button class="btn" id="generateWordBtn">‚ú® Example Word</button>
            <button class="btn" id="generateSentenceBtn">‚ú® Example Sentence</button>
            <button class="btn" id="generateKanaHistoryBtn">‚ú® History/Etymology</button>
            <button class="btn" id="showHandwritingCanvasBtn">‚úçÔ∏è Handwriting Practice</button>
            <button class="btn" id="generateGeneralTipsBtn">‚ú® Generate More Tips</button>
        </div>

        <!-- Moved LLM Features section here, directly after controls -->
        <div class="llm-features">
            <h3>Gemini AI Insights</h3>
            <div id="loadingIndicator" class="hidden">Generating...</div>

            <div id="exampleWordArea" class="info-card hidden">
                <h3>Example Word ‚ú® <button class="btn btn-sm" id="playWordAudioBtn">üîä</button></h3>
                <p id="exampleWordKana" class="practice-char small"></p>
                <p id="exampleWordRomaji"></p>
                <p id="exampleWordEnglish"></p>
            </div>
            
            <div id="sentenceArea" class="info-card hidden">
                <h3>Example Sentence ‚ú® <button class="btn btn-sm" id="playSentenceAudioBtn">üîä</button></h3>
                <p id="sentenceKana"></p>
                <p id="sentenceRomaji"></p>
                <p id="sentenceEnglish"></p>
            </div>

            <div id="kanaHistoryArea" class="info-card hidden">
                <h3>Kana History & Etymology ‚ú®</h3>
                <p id="kanaHistoryText" class="text-left"></p>
            </div>

            <div id="handwritingCanvasArea" class="info-card hidden">
                <h3>Handwriting Practice ‚úçÔ∏è</h3>
                <p>Draw the selected character: <span id="drawingCharDisplay"></span></p>
                <div class="canvas-container">
                    <canvas id="handwritingCanvas" width="150" height="150"></canvas>
                    <canvas id="referenceCanvas" width="150" height="150"></canvas>
                </div>
                <div style="display: flex; justify-content: center; gap: 10px; margin-top: 10px;">
                    <button class="btn" id="clearCanvasBtn">Clear My Drawing</button>
                    <button class="btn" id="clearFeedbackBtn">Clear AI Feedback</button>
                    <button class="btn" id="assessDrawingBtn">Assess Drawing (AI)</button>
                </div>
                <p id="handwritingFeedback" class="text-left" style="font-size: 0.9em; color: #333; margin-top: 10px;"></p>
                <p class="text-left" style="font-size: 0.8em; color: #666; margin-top: 5px;">
                    *AI handwriting recognition is experimental and may not be perfect for detailed calligraphy analysis.*
                </p>
            </div>
        </div>

        <div id="voiceStatus" class="voice-status hidden">
            <strong>Voice Status:</strong> <span id="voiceStatusText">Checking...</span>
        </div>

        <div id="basicCharts" class="chart-container">
            <div class="chart hiragana"><h2>„Å≤„Çâ„Åå„Å™ (Hiragana)</h2><div class="kana-grid" id="hiraganaGrid"></div></div>
            <div class="chart katakana"><h2>„Ç´„Çø„Ç´„Éä (Katakana)</h2><div class="kana-grid" id="katakanaGrid"></div></div>
        </div>

        <div id="dakutenCharts" class="chart-container hidden">
            <div class="chart hiragana"><h2>„Å≤„Çâ„Åå„Å™ (Dakuten & Handakuten)</h2><div class="kana-grid" id="hiraganaDakutenGrid"></div></div>
            <div class="chart katakana"><h2>„Ç´„Çø„Ç´„Éä (Dakuten & Handakuten)</h2><div class="kana-grid" id="katakanaDakutenGrid"></div></div>
        </div>

        <div class="practice-area">
            <h2>Practice Area</h2>
            <p class="practice-char" id="practiceChar">üéØ</p>
            <div class="practice-info">
                <div class="info-card">
                    <h3>Romaji</h3>
                    <p id="practiceRomaji">Select a character</p>
                </div>
                <div class="info-card">
                    <h3>üéµ Pronunciation Tip</h3>
                    <p id="pronunciationTip">Select a character!</p>
                </div>
            </div>
        </div>

        <div class="pronunciation-tips">
            <h2>General Pronunciation Tips</h2>
            <div class="tips-grid" id="generalTipsGrid">
                <!-- Initial static tips -->
                <div class="tip-item static-tip">Vowels: "a" as in "father", "i" as in "machine", "u" as in "flute", "e" as in "get", "o" as in "go".</div>
                <div class="tip-item static-tip">"tsu" („Å§) is pronounced like the "ts" in "cats".</div>
                <div class="tip-item static-tip">Double consonants (small „Å£/„ÉÉ) create a short pause before the next consonant.</div>
                <div class="tip-item static-tip">The "r" sound is a light tap, similar to the "tt" in the American English "butter".</div>
                <div class="tip-item static-tip">Mastering the five basic vowel sounds (a, i, u, e, o) is foundational for all Japanese pronunciation.</div>
                <!-- New AI-generated tips will be appended below here -->
            </div>
        </div>
    </div>

    <script>
        // Data for Kana
        const hiraganaBasic = {
            'a': '„ÅÇ', 'i': '„ÅÑ', 'u': '„ÅÜ', 'e': '„Åà', 'o': '„Åä', 'ka': '„Åã', 'ki': '„Åç', 'ku': '„Åè', 'ke': '„Åë', 'ko': '„Åì', 'sa': '„Åï', 'shi': '„Åó', 'su': '„Åô', 'se': '„Åõ', 'so': '„Åù', 'ta': '„Åü', 'chi': '„Å°', 'tsu': '„Å§', 'te': '„Å¶', 'to': '„Å®', 'na': '„Å™', 'ni': '„Å´', 'nu': '„Å¨', 'ne': '„Å≠', 'no': '„ÅÆ', 'ha': '„ÅØ', 'hi': '„Å≤', 'fu': '„Åµ', 'he': '„Å∏', 'ho': '„Åª', 'ma': '„Åæ', 'mi': '„Åø', 'mu': '„ÇÄ', 'me': '„ÇÅ', 'mo': '„ÇÇ', 'ya': '„ÇÑ', 'yu': '„ÇÜ', 'yo': '„Çà', 'ra': '„Çâ', 'ri': '„Çä', 'ru': '„Çã', 're': '„Çå', 'ro': '„Çç', 'wa': '„Çè', 'wo': '„Çí', 'n': '„Çì'
        };
        const katakanaBasic = {
            'a': '„Ç¢', 'i': '„Ç§', 'u': '„Ç¶', 'e': '„Ç®', 'o': '„Ç™', 'ka': '„Ç´', 'ki': '„Ç≠', 'ku': '„ÇØ', 'ke': '„Ç±', 'ko': '„Ç≥', 'sa': '„Çµ', 'shi': '„Ç∑', 'su': '„Çπ', 'se': '„Çª', 'so': '„ÇΩ', 'ta': '„Çø', 'chi': '„ÉÅ', 'tsu': '„ÉÑ', 'te': '„ÉÜ', 'to': '„Éà', 'na': '„Éä', 'ni': '„Éã', 'nu': '„Éå', 'ne': '„Éç', 'no': '„Éé', 'ha': '„Éè', 'hi': '„Éí', 'fu': '„Éï', 'he': '„Éò', 'ho': '„Éõ', 'ma': '„Éû', 'mi': '„Éü', 'mu': '„É†', 'me': '„É°', 'mo': '„É¢', 'ya': '„É§', 'yu': '„É¶', 'yo': '„É®', 'ra': '„É©', 'ri': '„É™', 'ru': '„É´', 're': '„É¨', 'ro': '„É≠', 'wa': '„ÉØ', 'wo': '„É≤', 'n': '„É≥'
        };
        const hiraganaDakuten = {
            'ga': '„Åå', 'gi': '„Åé', 'gu': '„Åê', 'ge': '„Åí', 'go': '„Åî', 'za': '„Åñ', 'ji': '„Åò', 'zu': '„Åö', 'ze': '„Åú', 'zo': '„Çæ', 'da': '„Å†', 'dji': '„Å¢', 'dzu': '„Å•', 'de': '„Åß', 'do': '„Å©', 'ba': '„Å∞', 'bi': '„Å≥', 'bu': '„Å∂', 'be': '„Åπ', 'bo': '„Åº', 'pa': '„Å±', 'pi': '„Å¥', 'pu': '„Å∑', 'pe': '„Å∫', 'po': '„ÅΩ'
        };
        const katakanaDakuten = {
            'ga': '„Ç¨', 'gi': '„ÇÆ', 'gu': '„Ç∞', 'ge': '„Ç≤', 'go': '„Ç¥', 'za': '„Ç∂', 'ji': '„Ç∏', 'zu': '„Ç∫', 'ze': '„Çº', 'zo': '„Çæ', 'da': '„ÉÄ', 'dji': '„ÉÇ', 'dzu': '„ÉÖ', 'de': '„Éá', 'do': '„Éâ', 'ba': '„Éê', 'bi': '„Éì', 'bu': '„Å∂', 'be': '„Åπ', 'bo': '„Åº', 'pa': '„Éë', 'pi': '„Éî', 'pu': '„Éó', 'pe': '„Éö', 'po': '„Éù'
        };
        
        // DOM Elements
        const hiraganaGrid = document.getElementById('hiraganaGrid');
        const katakanaGrid = document.getElementById('katakanaGrid');
        const hiraganaDakutenGrid = document.getElementById('hiraganaDakutenGrid');
        const katakanaDakutenGrid = document.getElementById('katakanaDakutenGrid');

        const btnBasic = document.getElementById('btnBasic');
        const btnDakuten = document.getElementById('btnDakuten');
        const audioBtn = document.getElementById('audioBtn');
        const basicCharts = document.getElementById('basicCharts');
        const dakutenCharts = document.getElementById('dakutenCharts');

        const practiceCharEl = document.getElementById('practiceChar');
        const practiceRomajiEl = document.getElementById('practiceRomaji');
        const pronunciationTipEl = document.getElementById('pronunciationTip'); // This will now show AI-generated tips
        const voiceStatusEl = document.getElementById('voiceStatus');
        const voiceStatusTextEl = document.getElementById('voiceStatusText');

        // New DOM Elements for LLM features
        const generateWordBtn = document.getElementById('generateWordBtn');
        const generateSentenceBtn = document.getElementById('generateSentenceBtn');
        const generateKanaHistoryBtn = document.getElementById('generateKanaHistoryBtn');
        const showHandwritingCanvasBtn = document.getElementById('showHandwritingCanvasBtn'); // Button for handwriting
        const generateGeneralTipsBtn = document.getElementById('generateGeneralTipsBtn'); // New button for general tips

        const loadingIndicator = document.getElementById('loadingIndicator');
        const exampleWordArea = document.getElementById('exampleWordArea');
        const exampleWordKanaEl = document.getElementById('exampleWordKana');
        const exampleWordRomajiEl = document.getElementById('exampleWordRomaji');
        const exampleWordEnglishEl = document.getElementById('exampleWordEnglish');
        const sentenceArea = document.getElementById('sentenceArea');
        const sentenceKanaEl = document.getElementById('sentenceKana');
        const sentenceRomajiEl = document.getElementById('sentenceRomaji');
        const sentenceEnglishEl = document.getElementById('sentenceEnglish');
        const kanaHistoryArea = document.getElementById('kanaHistoryArea');
        const kanaHistoryTextEl = document.getElementById('kanaHistoryText');

        const handwritingCanvasArea = document.getElementById('handwritingCanvasArea'); // Handwriting area
        const handwritingCanvas = document.getElementById('handwritingCanvas'); // User's drawing canvas
        const referenceCanvas = document.getElementById('referenceCanvas'); // Reference/shadow canvas
        const clearCanvasBtn = document.getElementById('clearCanvasBtn'); // Clear canvas button
        const clearFeedbackBtn = document.getElementById('clearFeedbackBtn'); // Clear AI feedback button
        const assessDrawingBtn = document.getElementById('assessDrawingBtn'); // New assess drawing button
        const drawingCharDisplay = document.getElementById('drawingCharDisplay'); // Display character to draw
        const handwritingFeedbackEl = document.getElementById('handwritingFeedback'); // Feedback element
        const generalTipsGrid = document.getElementById('generalTipsGrid'); // Container for general tips

        const playWordAudioBtn = document.getElementById('playWordAudioBtn'); // Audio button for word
        const playSentenceAudioBtn = document.getElementById('playSentenceAudioBtn'); // Audio button for sentence

        let selectedChar = null;
        let synthesizer = null;
        let wordTypeIndex = 0;
        const wordTypes = ["noun", "verb", "adjective", "adverb"];
        let sentenceTypeIndex = 0;
        const sentenceTypes = [
            "a simple declarative sentence",
            "a question",
            "a short phrase asking for something",
            "a polite greeting"
        ];

        // Canvas drawing variables
        let ctx = null; // Context for handwritingCanvas
        let refCtx = null; // Context for referenceCanvas
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        const CANVAS_BG_COLOR = '#f9f9f9'; // Must match CSS background-color of canvas
        const PENCIL_COLOR = '#333';
        const ERASER_COLOR = CANVAS_BG_COLOR; // Erases by drawing with background color
        const STROKE_WIDTH = 4; // Default stroke width for both pencil and eraser

        // Store generated tips to avoid immediate duplicates
        let currentGeneralTips = [];

        // Gemini API Key (Canvas will provide this at runtime)
        const API_KEY = " "; 

        // --- Grid Generation ---
        /**
         * Creates and populates a Kana grid within a given HTML element.
         * @param {HTMLElement} gridEl - The HTML element to which the grid will be appended.
         * @param {Object} kanaMap - A map of romaji to Kana characters (e.g., hiraganaBasic).
         * @param {string[]} headers - An array of header labels for the columns (e.g., ['A', 'I', 'U', 'E', 'O']).
         * @param {Object[]} rows - An array of row objects, each containing a header and an array of romaji for that row.
         */
        function createGrid(gridEl, kanaMap, headers, rows) {
            gridEl.innerHTML = ''; // Clear existing content
            // Add an empty cell for the top-left corner
            gridEl.appendChild(createCell('', 'header-cell'));
            // Add column headers
            headers.forEach(h => gridEl.appendChild(createCell(h, 'header-cell')));

            // Iterate through rows to populate the grid with Kana characters
            rows.forEach(row => {
                gridEl.appendChild(createCell(row.header, 'header-cell')); // Add row header
                row.romaji.forEach(romaji => {
                    const char = kanaMap[romaji]; // Get Kana character from the map
                    if (char) {
                        // If a character exists, create a clickable Kana cell
                        gridEl.appendChild(createCell(char, 'kana-cell', romaji));
                    } else {
                        // If no character, create an empty cell (for irregular grid layouts)
                        gridEl.appendChild(createCell('', 'empty-cell'));
                    }
                });
            });
        }

        /**
         * Creates a single cell for the Kana grid.
         * @param {string} content - The Kana character or header text for the cell.
         * @param {string} className - The CSS class for the cell (e.g., 'kana-cell', 'header-cell').
         * @param {string} [romaji=''] - The romaji pronunciation for 'kana-cell' types.
         * @returns {HTMLElement} The created div element representing the cell.
         */
        function createCell(content, className, romaji = '') {
            const cell = document.createElement('div');
            cell.className = `kana-cell ${className}`; // Apply base and specific classes
            if (className === 'kana-cell') {
                // For Kana character cells, add both character and romaji, and an onclick handler
                cell.innerHTML = `<div class="kana-char">${content}</div><div class="kana-romaji">${romaji}</div>`;
                cell.onclick = (event) => selectCharacter(content, romaji, event); // Pass event object
            } else {
                // For header or empty cells, just add text content
                cell.textContent = content;
            }
            return cell;
        }

        // Headers and rows for basic Kana charts
        const basicHeaders = ['A', 'I', 'U', 'E', 'O'];
        const basicRows = [
            { header: '', romaji: ['a', 'i', 'u', 'e', 'o'] },
            { header: 'K', romaji: ['ka', 'ki', 'ku', 'ke', 'ko'] },
            { header: 'S', romaji: ['sa', 'shi', 'su', 'se', 'so'] },
            { header: 'T', romaji: ['ta', 'chi', 'tsu', 'te', 'to'] },
            { header: 'N', romaji: ['na', 'ni', 'nu', 'ne', 'no'] },
            { header: 'H', romaji: ['ha', 'hi', 'fu', 'he', 'ho'] },
            { header: 'M', romaji: ['ma', 'mi', 'mu', 'me', 'mo'] },
            { header: 'Y', romaji: ['ya', '', 'yu', '', 'yo'] }, // Empty strings for missing characters
            { header: 'R', romaji: ['ra', 'ri', 'ru', 're', 'ro'] },
            { header: 'W', romaji: ['wa', '', '', '', 'wo'] },
            { header: 'N', romaji: ['n', '', '', '', ''] }
        ];

        // Headers and rows for Dakuten & Handakuten Kana charts
        const dakutenRows = [
            { header: 'G', romaji: ['ga', 'gi', 'gu', 'ge', 'go'] },
            { header: 'Z', romaji: ['za', 'ji', 'zu', 'ze', 'zo'] },
            { header: 'D', romaji: ['da', 'dji', 'dzu', 'de', 'do'] },
            { header: 'B', romaji: ['ba', 'bi', 'bu', 'be', 'bo'] },
            { header: 'P', romaji: ['pa', 'pi', 'pu', 'pe', 'po'] }
        ];

        // --- UI Interaction ---
        /**
         * Handles the selection of a Kana character from the grid.
         * Updates the practice area and plays the audio.
         * @param {string} char - The selected Kana character.
         * @param {string} romaji - The romaji pronunciation of the selected character.
         * @param {Event} event - The click event object.
         */
        async function selectCharacter(char, romaji, event) {
            // Remove 'selected' class from previously selected cells
            document.querySelectorAll('.kana-cell.selected').forEach(c => c.classList.remove('selected'));
            // Add 'selected' class to the clicked cell
            event.currentTarget.classList.add('selected');

            selectedChar = char; // Store the selected character globally
            practiceCharEl.textContent = char; // Update practice area character
            practiceRomajiEl.textContent = romaji; // Update practice area romaji

            // Play audio for the selected character immediately
            playAudio(selectedChar); 

            // Hide all LLM generated content and drawing canvas when a new character is selected
            exampleWordArea.classList.add('hidden');
            sentenceArea.classList.add('hidden');
            kanaHistoryArea.classList.add('hidden');
            handwritingCanvasArea.classList.add('hidden'); // Hide drawing canvas area
            handwritingFeedbackEl.textContent = ''; // Clear feedback

            // Generate AI pronunciation tip for the selected character (now happens after audio)
            await generatePronunciationTip(char, romaji);
        }

        /**
         * Switches between the basic Kana view and the Dakuten/Handakuten view.
         * @param {boolean} isBasic - True to show basic charts, false to show dakuten charts.
         */
        function switchView(isBasic) {
            btnBasic.classList.toggle('active', isBasic);
            btnDakuten.classList.toggle('active', !isBasic);
            basicCharts.classList.toggle('hidden', !isBasic);
            dakutenCharts.classList.toggle('hidden', isBasic);
            clearSelection(); // Clear selection when switching views
        }

        /**
         * Clears the current character selection and resets the practice area.
         */
        function clearSelection() {
            document.querySelectorAll('.kana-cell.selected').forEach(c => c.classList.remove('selected'));
            selectedChar = null;
            practiceCharEl.textContent = 'üéØ'; // Reset practice character
            practiceRomajiEl.textContent = 'Select a character'; // Reset romaji
            pronunciationTipEl.textContent = 'Select a character!'; // Reset tip
            
            // Also clear and hide all LLM generated content and drawing canvas
            exampleWordArea.classList.add('hidden');
            sentenceArea.classList.add('hidden');
            sentenceKanaEl.textContent = '';
            sentenceRomajiEl.textContent = '';
            sentenceEnglishEl.textContent = '';
            kanaHistoryArea.classList.add('hidden');
            kanaHistoryTextEl.textContent = '';
            handwritingCanvasArea.classList.add('hidden'); // Hide drawing canvas area
            if (ctx) {
                ctx.clearRect(0, 0, handwritingCanvas.width, handwritingCanvas.height); // Clear user canvas
            }
            if (refCtx) { // Also clear the reference canvas for a clean slate when switching away
                refCtx.clearRect(0, 0, referenceCanvas.width, referenceCanvas.height);
            }
            drawingCharDisplay.textContent = ''; // Clear drawing character display
            handwritingFeedbackEl.textContent = ''; // Clear feedback
        }

        // Attach event listeners to view switching buttons
        btnBasic.onclick = () => switchView(true);
        btnDakuten.onclick = () => switchView(false);

        // --- Audio Synthesis ---
        let jpVoice = null; // Store the Japanese voice once found

        /**
         * Checks browser support for Speech Synthesis and sets up the voice.
         * Updates the voice status display and enables/disables the audio button.
         */
        function checkVoiceSupport() {
            console.log("Checking voice support...");
            if ('speechSynthesis' in window) {
                synthesizer = window.speechSynthesis; // Get the SpeechSynthesis API instance

                const findAndSetVoice = () => {
                    console.log("Voices changed, attempting to set voice.");
                    // Find a Japanese voice, using startsWith('ja') for broader compatibility
                    jpVoice = synthesizer.getVoices().find(v => v.lang.startsWith('ja'));
                    if (jpVoice) {
                        voiceStatusEl.className = 'voice-status success'; // Set status to success
                        voiceStatusTextEl.textContent = 'Japanese voice ready!';
                        audioBtn.disabled = false; // Enable main audio button
                        if (playWordAudioBtn) playWordAudioBtn.disabled = false;
                        if (playSentenceAudioBtn) playSentenceAudioBtn.disabled = false;
                        console.log("Japanese voice found:", jpVoice.name);
                    } else {
                        voiceStatusEl.className = 'voice-status error'; // Set status to error
                        voiceStatusTextEl.textContent = 'Japanese voice not found in your browser.';
                        audioBtn.disabled = true; // Disable main audio button
                        if (playWordAudioBtn) playWordAudioBtn.disabled = true;
                        if (playSentenceAudioBtn) playSentenceAudioBtn.disabled = true;
                        console.warn("Japanese voice not found. Available voices:", synthesizer.getVoices().map(v => v.lang + ' ' + v.name));
                    }
                    voiceStatusEl.classList.remove('hidden'); // Show the voice status element
                };
                
                // If voices are already loaded, set the voice immediately, otherwise wait for 'onvoiceschanged' event
                if (synthesizer.getVoices().length) {
                    findAndSetVoice();
                } else {
                    // This event ensures the voices are loaded before trying to find them
                    synthesizer.onvoiceschanged = findAndSetVoice;
                    console.log("Waiting for voices to load...");
                }
            } else {
                // If speech synthesis is not supported
                voiceStatusEl.className = 'voice-status error'; // Set status to error
                voiceStatusTextEl.textContent = 'Speech synthesis not supported by this browser.';
                audioBtn.disabled = true; // Disable main audio button
                if (playWordAudioBtn) playWordAudioBtn.disabled = true;
                if (playSentenceAudioBtn) playSentenceAudioBtn.disabled = true;
                voiceStatusEl.classList.remove('hidden'); // Show the voice status element
                console.error("SpeechSynthesis API not supported by this browser.");
            }
        }

        /**
         * Plays the audio pronunciation of the given text.
         * @param {string} textToSpeak - The text string to be spoken.
         */
        function playAudio(textToSpeak) {
            console.log(`Attempting to play audio for: "${textToSpeak}"`);
            if (!textToSpeak || !synthesizer || audioBtn.disabled || !jpVoice) {
                console.warn("Audio playback aborted: missing text, synthesizer, Japanese voice, or button disabled.");
                return;
            }

            // Immediately cancel any ongoing speech to prevent queuing and ensure responsiveness
            if (synthesizer.speaking) {
                synthesizer.cancel();
                console.log("Cancelled previous speech.");
            }
            
            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            utterance.lang = 'ja-JP';
            utterance.voice = jpVoice; // Use the stored voice
            synthesizer.speak(utterance);
            console.log(`Started new speech for: "${textToSpeak}"`);
        }
        audioBtn.onclick = () => playAudio(selectedChar); // Attach playAudio to the main audio button click event

        // --- LLM Powered Features ---

        /**
         * Shows the loading indicator and hides the specified element.
         * @param {HTMLElement} [elementToHide] - The element to hide while loading.
         */
        function showLoading(elementToHide) {
            loadingIndicator.classList.remove('hidden');
            if (elementToHide) {
                elementToHide.classList.add('hidden'); // Hide the target area while loading
            }
        }

        /**
         * Hides the loading indicator and shows the specified element.
         * @param {HTMLElement} [elementToShow] - The element to show after loading.
         */
        function hideLoading(elementToShow) {
            loadingIndicator.classList.add('hidden');
            if (elementToShow) {
                elementToShow.classList.remove('hidden'); // Show the target area after loading
            }
        }

        /**
         * Displays a custom message box to the user.
         * @param {string} message - The message to display.
         * @param {'info'|'error'|'success'} [type='info'] - The type of message, influences styling.
         */
        function showMessageBox(message, type = 'info') {
            let messageBox = document.getElementById('customMessageBox');
            if (!messageBox) {
                // Create message box element if it doesn't exist
                messageBox = document.createElement('div');
                messageBox.id = 'customMessageBox';
                messageBox.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    padding: 20px;
                    background-color: white;
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                    z-index: 1000;
                    text-align: center;
                    max-width: 300px;
                    color: #333;
                `;
                document.body.appendChild(messageBox);
            }

            // Set message box content
            messageBox.innerHTML = `
                <p>${message}</p>
                <button id="closeMessageBox" style="
                    margin-top: 15px;
                    padding: 8px 15px;
                    border: none;
                    border-radius: 5px;
                    background-color: #1877f2;
                    color: white;
                    cursor: pointer;
                ">OK</button>
            `;
            messageBox.style.display = 'block'; // Make it visible

            // Close button functionality
            document.getElementById('closeMessageBox').onclick = () => {
                messageBox.style.display = 'none';
            };

            // Optional: styling based on message type
            if (type === 'error') {
                messageBox.style.borderColor = '#d12f2f';
                messageBox.style.color = '#d12f2f';
            } else if (type === 'success') {
                messageBox.style.borderColor = '#2e7d32';
                messageBox.style.color = '#2e7d32';
            } else { // info
                messageBox.style.borderColor = '#1877f2';
                messageBox.style.color = '#333';
            }
        }

        /**
         * Generates an AI-powered pronunciation tip for the selected Kana character.
         * @param {string} char - The Kana character.
         * @param {string} romaji - The Romaji of the character.
         */
        async function generatePronunciationTip(char, romaji) {
            pronunciationTipEl.textContent = 'Generating tip...'; // Show loading for tip
            const prompt = `Provide a concise, 1-sentence pronunciation tip for the Japanese character "${char}" (Romaji: "${romaji}"). Focus on common pitfalls or English sound analogies. If no specific tip, state that it's straightforward. Format as JSON: {"tip": "Your tip here."}`;
            try {
                const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: { type: "OBJECT", properties: { "tip": { "type": "STRING" } } }
                    }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                if (result.candidates && result.candidates[0] && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                    const parsed = JSON.parse(result.candidates[0].content.parts[0].text);
                    pronunciationTipEl.textContent = parsed.tip || 'Could not generate tip.';
                } else {
                    console.error("AI pronunciation tip response unexpected:", result);
                    pronunciationTipEl.textContent = 'Tip unavailable.';
                }
            } catch (error) {
                console.error("Error generating pronunciation tip:", error);
                pronunciationTipEl.textContent = 'Error fetching tip.';
            }
        }


        /**
         * Generates a simple example Japanese word using the selected Kana character
         * and displays it in the example word area.
         */
        async function generateExampleWord() {
            if (!selectedChar || !practiceRomajiEl.textContent) {
                showMessageBox("Please select a Kana character first to get an example word!", "info");
                return;
            }

            showLoading(exampleWordArea); // Show loading, hide example area
            // Clear previous content
            exampleWordKanaEl.textContent = '';
            exampleWordRomajiEl.textContent = '';
            exampleWordEnglishEl.textContent = '';
            // Hide other LLM areas
            sentenceArea.classList.add('hidden');
            kanaHistoryArea.classList.add('hidden');
            handwritingCanvasArea.classList.add('hidden');

            const currentWordType = wordTypes[wordTypeIndex];
            wordTypeIndex = (wordTypeIndex + 1) % wordTypes.length; // Cycle through types

            // Construct the prompt for the LLM, requesting a specific type of word
            // IMPORTANT: Explicitly asking for the character to be included
            const prompt = `Give me a single, very simple Japanese word (a common ${currentWordType}) that uses and clearly contains the character "${selectedChar}" (Romaji: "${practiceRomajiEl.textContent}"). The word should be easy for a beginner. Provide the Japanese word, its Romaji, and its English meaning. Format your response as a JSON object with keys "japanese", "romaji", and "english". For example: {"japanese": "„Å≠„Åì", "romaji": "neko", "english": "cat"}`;

            try {
                const chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "japanese": { "type": "STRING" },
                                "romaji": { "type": "STRING" },
                                "english": { "type": "STRING" }
                            },
                            "propertyOrdering": ["japanese", "romaji", "english"] // Maintain order
                        }
                    }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                // Check for valid response structure
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const json = result.candidates[0].content.parts[0].text;
                    const parsedJson = JSON.parse(json);

                    // Update UI with generated word
                    exampleWordKanaEl.textContent = parsedJson.japanese || 'N/A';
                    exampleWordRomajiEl.textContent = parsedJson.romaji ? `Romaji: ${parsedJson.romaji}` : 'Romaji: N/A';
                    exampleWordEnglishEl.textContent = parsedJson.english ? `English: ${parsedJson.english}` : 'English: N/A';

                    // Play audio for the generated word
                    if (playWordAudioBtn) {
                        playWordAudioBtn.onclick = () => playAudio(parsedJson.japanese);
                    }

                } else {
                    console.error("Gemini API response structure unexpected:", result);
                    showMessageBox("Could not generate example word. Please try again.", "error");
                }
            } catch (error) {
                console.error("Error generating example word:", error);
                showMessageBox("Error generating example word. Please check your connection or try again later.", "error");
            } finally {
                hideLoading(exampleWordArea); // Hide loading, show example area
            }
        }

        /**
         * Generates an example Japanese sentence using the selected Kana character.
         */
        async function generateSentence() {
            if (!selectedChar || !practiceRomajiEl.textContent) {
                showMessageBox("Please select a Kana character first to get an example sentence!", "info");
                return;
            }

            showLoading(sentenceArea); // Show loading, hide sentence area
            sentenceKanaEl.textContent = '';
            sentenceRomajiEl.textContent = '';
            sentenceEnglishEl.textContent = '';
            // Hide other LLM areas
            exampleWordArea.classList.add('hidden');
            kanaHistoryArea.classList.add('hidden');
            handwritingCanvasArea.classList.add('hidden');

            const currentSentenceType = sentenceTypes[sentenceTypeIndex];
            sentenceTypeIndex = (sentenceTypeIndex + 1) % sentenceTypes.length; // Cycle through types

            // IMPORTANT: Explicitly asking for the character to be included
            const prompt = `Generate a very simple, short Japanese sentence that uses and clearly contains the character "${selectedChar}" (Romaji: "${practiceRomajiEl.textContent}"). The sentence should be ${currentSentenceType}. Provide the Japanese sentence, its Romaji, and its English meaning. Format your response as a JSON object with keys "japanese", "romaji", and "english". For example: {"japanese": "„Åì„Çå„ÅØ„Éö„É≥„Åß„Åô", "romaji": "kore wa pen desu", "english": "This is a pen."}`;

            try {
                const chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "japanese": { "type": "STRING" },
                                "romaji": { "type": "STRING" },
                                "english": { "type": "STRING" }
                            },
                            "propertyOrdering": ["japanese", "romaji", "english"]
                        }
                    }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const json = result.candidates[0].content.parts[0].text;
                    const parsedJson = JSON.parse(json);
                    sentenceKanaEl.textContent = parsedJson.japanese || 'N/A';
                    sentenceRomajiEl.textContent = parsedJson.romaji ? `Romaji: ${parsedJson.romaji}` : 'Romaji: N/A';
                    sentenceEnglishEl.textContent = parsedJson.english ? `English: ${parsedJson.english}` : 'English: N/A';

                    // Play audio for the generated sentence
                    if (playSentenceAudioBtn) {
                        playSentenceAudioBtn.onclick = () => playAudio(parsedJson.japanese); // Log the text being spoken
                    }

                } else {
                    console.error("Gemini API response structure unexpected:", result);
                    showMessageBox("Could not generate example sentence. Please try again.", "error");
                }
            } catch (error) {
                console.error("Error generating example sentence:", error);
                showMessageBox("Error generating example sentence. Please check your connection or try again later.", "error");
            } finally {
                hideLoading(sentenceArea); // Hide loading, show sentence area
            }
        }

        /**
         * Generates a brief history/etymology for the selected Kana character.
         */
        async function generateKanaHistory() {
            if (!selectedChar || !practiceRomajiEl.textContent) {
                showMessageBox("Please select a Kana character first to get its history!", "info");
                return;
            }

            showLoading(kanaHistoryArea); // Show loading, hide history area
            kanaHistoryTextEl.textContent = ''; // Clear previous content
            // Hide other LLM areas
            exampleWordArea.classList.add('hidden');
            sentenceArea.classList.add('hidden');
            handwritingCanvasArea.classList.add('hidden');

            const prompt = `Provide a very brief (1-2 sentences) interesting fact or etymology about the Japanese character "${selectedChar}" (Romaji: "${practiceRomajiEl.textContent}"). Focus on its origin from Kanji or a notable historical aspect. Format the response as a JSON object with a 'fact' key. Example for "„ÅÇ": {"fact": "Hiragana '„ÅÇ' originated from the simplified form of the Kanji character 'ÂÆâ' (an), meaning 'peace' or 'cheap'."}`;

            try {
                const chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "fact": { "type": "STRING" }
                            }
                        }
                    }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const json = result.candidates[0].content.parts[0].text;
                    const parsedJson = JSON.parse(json);
                    kanaHistoryTextEl.textContent = parsedJson.fact || 'Could not retrieve history/etymology.';
                } else {
                    console.error("Gemini API response structure unexpected:", result);
                    showMessageBox("Could not generate history/etymology. Please try again.", "error");
                }
            } catch (error) {
                console.error("Error generating history/etymology:", error);
                showMessageBox("Error generating history/etymology. Please check your connection or try again later.", "error");
            } finally {
                hideLoading(kanaHistoryArea); // Hide loading, show history area
            }
        }

        /**
         * Initializes and displays the handwriting practice canvases.
         */
        function showHandwritingCanvas() {
            if (!selectedChar) {
                showMessageBox("Please select a Kana character first to practice handwriting!", "info");
                return;
            }

            // Hide other LLM areas
            exampleWordArea.classList.add('hidden');
            sentenceArea.classList.add('hidden');
            kanaHistoryArea.classList.add('hidden');

            // Show handwriting canvas area
            handwritingCanvasArea.classList.remove('hidden');
            drawingCharDisplay.textContent = selectedChar;
            handwritingFeedbackEl.textContent = ''; // Clear previous feedback

            // Initialize canvas contexts if not already done
            if (!ctx) {
                ctx = handwritingCanvas.getContext('2d');
                ctx.lineWidth = STROKE_WIDTH;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round'; // Ensure smooth line joins
                ctx.strokeStyle = PENCIL_COLOR; // Default to pencil color
                ctx.globalCompositeOperation = 'source-over'; // Default to drawing mode
            }
            if (!refCtx) {
                refCtx = referenceCanvas.getContext('2d');
            }
            
            ctx.clearRect(0, 0, handwritingCanvas.width, handwritingCanvas.height); // Clear user's drawing canvas
            refCtx.clearRect(0, 0, referenceCanvas.width, referenceCanvas.height); // Clear reference canvas initially

            // Draw the shadow immediately and permanently when showing the canvas area
            if (selectedChar) {
                drawCharacterShadow(selectedChar);
            }

            // Set up drawing event listeners for the handwriting canvas only
            handwritingCanvas.addEventListener('mousedown', startDrawing);
            handwritingCanvas.addEventListener('mouseup', stopDrawing);
            handwritingCanvas.addEventListener('mouseout', stopDrawing); // Stop drawing if mouse leaves canvas
            handwritingCanvas.addEventListener('mousemove', draw);
            handwritingCanvas.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevent right-click context menu

            // Touch events for mobile on handwriting canvas only
            handwritingCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scrolling
                // For touch, we assume pencil. Eraser typically needs a separate UI button on touch.
                ctx.strokeStyle = PENCIL_COLOR;
                ctx.globalCompositeOperation = 'source-over';
                startDrawing(e.touches[0]);
            });
            handwritingCanvas.addEventListener('touchend', stopDrawing);
            handwritingCanvas.addEventListener('touchcancel', stopDrawing);
            handwritingCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault(); // Prevent scrolling
                draw(e.touches[0]);
            });
        }

        /**
         * Starts the drawing process on the main handwriting canvas.
         * Sets tool (pencil/eraser) based on mouse button.
         * @param {Event} event - Mouse or touch event.
         */
        function startDrawing(event) {
            isDrawing = true;
            const rect = handwritingCanvas.getBoundingClientRect();
            // Check if it's a mouse event and which button is pressed
            if (event.button === 0) { // Left-click for pencil
                ctx.strokeStyle = PENCIL_COLOR;
                ctx.globalCompositeOperation = 'source-over';
            } else if (event.button === 2) { // Right-click for eraser
                ctx.strokeStyle = ERASER_COLOR;
                ctx.globalCompositeOperation = 'destination-out'; // This operation erases pixels
            }
            [lastX, lastY] = [event.clientX - rect.left, event.clientY - rect.top];
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
        }

        /**
         * Stops the drawing process on the main handwriting canvas.
         * Resets globalCompositeOperation to default.
         */
        function stopDrawing() {
            isDrawing = false;
            // Always reset to 'source-over' after drawing/erasing to ensure default drawing behavior
            ctx.globalCompositeOperation = 'source-over'; 
        }

        /**
         * Draws on the main handwriting canvas based on mouse/touch movement.
         * @param {Event} event - Mouse or touch event.
         */
        function draw(event) {
            if (!isDrawing) return;
            const rect = handwritingCanvas.getBoundingClientRect();
            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;
            ctx.lineTo(currentX, currentY);
            ctx.stroke();
            [lastX, lastY] = [currentX, currentY];
        }

        /**
         * Clears the user's handwriting canvas.
         */
        function clearHandwritingCanvas() {
            if (ctx) {
                ctx.clearRect(0, 0, handwritingCanvas.width, handwritingCanvas.height);
            }
            // Do NOT clear refCtx here. The shadow should persist.
        }

        /**
         * Clears only the AI assessment feedback text.
         */
        function clearAssessmentFeedback() {
            handwritingFeedbackEl.textContent = '';
        }

        /**
         * Draws a faded shadow of the correct character on the reference canvas.
         * This shadow now stays permanently.
         * @param {string} char - The character to draw as a shadow.
         */
        function drawCharacterShadow(char) {
            if (!refCtx) return;

            refCtx.clearRect(0, 0, referenceCanvas.width, referenceCanvas.height); // Clear any previous shadow

            refCtx.save();
            refCtx.globalAlpha = 0.2; // Faded
            refCtx.fillStyle = '#1877f2'; // Blue shadow
            refCtx.font = '100px sans-serif'; // Large font for clear character
            refCtx.textAlign = 'center';
            refCtx.textBaseline = 'middle';
            refCtx.fillText(char, referenceCanvas.width / 2, referenceCanvas.height / 2 + 10);
            refCtx.restore();
        }


        /**
         * Converts canvas content to a Base64 image and sends it to Gemini for assessment.
         */
        async function assessDrawing() {
            if (!selectedChar) {
                showMessageBox("Please select a Kana character first to assess your drawing!", "info");
                return;
            }

            handwritingFeedbackEl.textContent = 'Assessing drawing...';
            showLoading(null); // Show global loading indicator

            // Get canvas content as base64 image data ONLY from the handwritingCanvas
            const imageDataUrl = handwritingCanvas.toDataURL('image/png');
            const base64ImageData = imageDataUrl.split(',')[1]; // Remove "data:image/png;base64," prefix

            // Previous prompt before the changes for "correct aspects" and Imagen API for stroke order
            const prompt = `Analyze the Japanese character drawn in the image. The target character is "${selectedChar}". Provide specific, actionable feedback on how to improve the handwriting. Focus on 2-3 key aspects such as stroke formation (e.g., straightness, curves, connections), proportions (e.g., balance of parts, size), and overall balance of the character. Also, give a percentage score from 0 to 100 indicating how well the drawing matches the target character, where 100% is a perfect match. Format your response as a JSON object with an 'assessment' key for the detailed feedback and a 'percentage' key for the score. Example: {"assessment": "Your vertical strokes are good, but try to make the horizontal lines slightly more curved for better flow. The overall proportion is fair.", "percentage": 75}`;

            try {
                const chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = {
                    contents: [
                        {
                            role: "user",
                            parts: [
                                { text: prompt },
                                {
                                    inlineData: {
                                        mimeType: "image/png",
                                        data: base64ImageData
                                    }
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "assessment": { "type": "STRING" },
                                "percentage": { "type": "NUMBER" } // Expecting a number for percentage
                            },
                            "propertyOrdering": ["assessment", "percentage"]
                        }
                    }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const json = result.candidates[0].content.parts[0].text;
                    const parsedJson = JSON.parse(json);
                    
                    const assessmentText = parsedJson.assessment || 'Could not provide assessment.';
                    const percentage = typeof parsedJson.percentage === 'number' ? `${Math.round(parsedJson.percentage)}%` : 'N/A';

                    handwritingFeedbackEl.textContent = `AI Feedback: ${assessmentText} (Score: ${percentage})`;
                    drawCharacterShadow(selectedChar); // Redraw shadow on reference canvas (which is now permanent)
                } else {
                    console.error("Gemini API response structure unexpected:", result);
                    handwritingFeedbackEl.textContent = 'AI Feedback: Could not assess drawing. Please try again.';
                }
            } catch (error) {
                console.error("Error assessing drawing:", error);
                handwritingFeedbackEl.textContent = 'AI Feedback: Error during assessment. Please check your connection or try again later.';
            } finally {
                hideLoading(null); // Hide global loading indicator
            }
        }

        /**
         * Populates initial static tips and retrieves existing tips.
         */
        function initializeGeneralTips() {
            currentGeneralTips = [];
            // Collect existing static tips
            document.querySelectorAll('#generalTipsGrid .static-tip').forEach(tipEl => {
                currentGeneralTips.push(tipEl.textContent.trim());
            });
            console.log("Initialized static tips:", currentGeneralTips);
        }

        /**
         * Generates a list of general pronunciation tips using Gemini and displays them.
         */
        async function generateGeneralTips() {
            // Add a temporary loading message to the tips grid
            const loadingTip = document.createElement('div');
            loadingTip.classList.add('tip-item');
            loadingTip.textContent = 'Generating more tips...';
            generalTipsGrid.appendChild(loadingTip);

            // Construct prompt, asking for tips different from current ones
            const prompt = `Generate 5 new, concise, actionable general pronunciation tips for learning Japanese Hiragana/Katakana. Each tip should be 1-2 sentences. Do not mention specific characters. Ensure these tips are different from the following existing tips: [${currentGeneralTips.map(tip => `"${tip}"`).join(', ')}]. Format as a JSON array of strings, e.g., ["Tip 1.", "Tip 2."].`;

            try {
                const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "ARRAY",
                            items: { "type": "STRING" }
                        }
                    }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                // Remove the loading message before adding new tips
                generalTipsGrid.removeChild(loadingTip);

                if (result.candidates && result.candidates[0] && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                    const newTips = JSON.parse(result.candidates[0].content.parts[0].text);
                    if (Array.isArray(newTips) && newTips.length > 0) {
                        newTips.forEach(tip => {
                            // Only add if not already present (basic client-side deduplication)
                            if (!currentGeneralTips.includes(tip.trim())) {
                                const tipItem = document.createElement('div');
                                tipItem.classList.add('tip-item');
                                tipItem.textContent = tip;
                                generalTipsGrid.appendChild(tipItem);
                                currentGeneralTips.push(tip.trim()); // Add to tracking list
                            }
                        });
                        console.log("New tips added. All current tips:", currentGeneralTips);
                    } else {
                        const noTipsItem = document.createElement('div');
                        noTipsItem.classList.add('tip-item');
                        noTipsItem.textContent = 'No new tips generated.';
                        generalTipsGrid.appendChild(noTipsItem);
                    }
                } else {
                    console.error("AI general tips response unexpected:", result);
                    const errorTipItem = document.createElement('div');
                    errorTipItem.classList.add('tip-item');
                    errorTipItem.textContent = 'Could not generate general tips.';
                    generalTipsGrid.appendChild(errorTipItem);
                }
            } catch (error) {
                console.error("Error generating general tips:", error);
                const errorTipItem = document.createElement('div');
                errorTipItem.classList.add('tip-item');
                errorTipItem.textContent = 'Error fetching general tips.';
                generalTipsGrid.appendChild(errorTipItem);
            }
        }


        // --- Initial Load ---
        // Ensure DOM is fully loaded before initializing the grids and voice support
        document.addEventListener('DOMContentLoaded', () => {
            // Create and populate all Kana grids
            createGrid(hiraganaGrid, hiraganaBasic, basicHeaders, basicRows);
            createGrid(katakanaGrid, katakanaBasic, basicHeaders, basicRows);
            createGrid(hiraganaDakutenGrid, hiraganaDakuten, basicHeaders, dakutenRows);
            createGrid(katakanaDakutenGrid, katakanaDakuten, basicHeaders, dakutenRows);
            
            // Check and set up voice synthesis
            checkVoiceSupport();
            // Initialize the list of general tips
            initializeGeneralTips();

            // Attach event listeners for LLM features, animation, and handwriting
            generateWordBtn.onclick = generateExampleWord;
            generateSentenceBtn.onclick = generateSentence;
            generateKanaHistoryBtn.onclick = generateKanaHistory;
            showHandwritingCanvasBtn.onclick = showHandwritingCanvas;
            clearCanvasBtn.onclick = clearHandwritingCanvas; // Attach clear button handler
            clearFeedbackBtn.onclick = clearAssessmentFeedback; // Attach clear feedback button handler
            assessDrawingBtn.onclick = assessDrawing; // Attach assess drawing button handler
            generateGeneralTipsBtn.onclick = generateGeneralTips; // Attach general tips button handler

        });
    </script>
</body>
</html>
